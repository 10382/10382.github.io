{"title":"PDU数据采集","slug":"PDU数据采集","date":"2019-04-21T12:50:13.000Z","updated":"2019-04-21T14:28:34.262Z","comments":true,"excerpt":"","content":"<blockquote>\n<p>题图画师: <a href=\"https://www.pixiv.net/member.php?id=1922517\" target=\"_blank\" rel=\"noopener\">KiTA</a> 原图: <a href=\"https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=62341877\" target=\"_blank\" rel=\"noopener\">出处</a></p>\n</blockquote>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>需要通过电源分配单元 PDU (Power Distribution Unit)采集服务器功耗信息，但又没有动环系统来自动采集 PDU 数据，所以只能将另一台主机通过串口连接到 PDU 的串口并编写请求脚本来采集 PDU 数据。</p>\n<h2 id=\"硬件配置\"><a href=\"#硬件配置\" class=\"headerlink\" title=\"硬件配置\"></a>硬件配置</h2><h3 id=\"PDU\"><a href=\"#PDU\" class=\"headerlink\" title=\"PDU\"></a>PDU</h3><p>PDU 购买于某东，可以说是小型且可本地监测并收集数据中比较便宜的了。</p>\n<p><img src=\"https://ae01.alicdn.com/kf/HTB1o6XdR7voK1RjSZFw763iCFXag.png\" alt=\"麒智4位4口10A万用孔PDU\"></p>\n<h3 id=\"USB-转串口器\"><a href=\"#USB-转串口器\" class=\"headerlink\" title=\"USB 转串口器\"></a>USB 转串口器</h3><p>为了能让主机能和 PDU 上的类似网口的 RS485 串口通信，从某宝淘了一款支持与 RS485 的 USB 转串口转换器，看商品详情挺可靠的，而且支持Linux，还提供串口测试软件，就决定是你了！</p>\n<p><img src=\"https://ae01.alicdn.com/kf/HTB10qU5RH2pK1RjSZFsq6yNlXXaU.jpg\" alt=\"数之路USB串口转换器\"></p>\n<p>该商品还提供包含网线转接端子的套餐，为了保险起见，我也一起淘来了。</p>\n<p><img src=\"https://ae01.alicdn.com/kf/HTB1sNA7RMHqK1RjSZFgq6y7JXXao.jpg\" alt=\"网线转接端子\"></p>\n<h2 id=\"RS485-接口连接\"><a href=\"#RS485-接口连接\" class=\"headerlink\" title=\"RS485 接口连接\"></a>RS485 接口连接</h2><p>为了能让能让两端串口完美通信，需要确认两端的<strong>网口线序</strong>是否相同。于是翻出 PDU 手册和 <a href=\"http://www.tcpwifi.com/c456.html\" target=\"_blank\" rel=\"noopener\">转换器手册</a>进行对比，可以发现他们两个的网口线序确实不一样，需要自己通过端子接口手工 DIY 一下。</p>\n<ul>\n<li><p>PDU 线序</p>\n<p><img src=\"https://ae01.alicdn.com/kf/HTB1elcERYvpK1RjSZPi762mwXXak.png\" alt=\"PDU线序图\"></p>\n</li>\n<li><p>USB 转串口转换器线序</p>\n<p><img src=\"https://ae01.alicdn.com/kf/HTB1vo0Efe3tHKVjSZSg7604QFXaY.png\" alt=\"转换器线序图\"></p>\n</li>\n</ul>\n<h3 id=\"PDU-端-RS485-串口线序修改\"><a href=\"#PDU-端-RS485-串口线序修改\" class=\"headerlink\" title=\"PDU 端 RS485 串口线序修改\"></a>PDU 端 RS485 串口线序修改</h3><p>通过端子接口把原来PDU 485的接口线序从(5脚: B-; 4脚: A+)修改为与USB转串口装置的线序相同(7脚: B-; 8脚: A+)</p>\n<p><img src=\"https://ae01.alicdn.com/kf/HTB178ERRZfpK1RjSZFO7616nFXaj.png\" alt=\"485连接示意图\"></p>\n<p>再通过普通网线将端子接口和USB转串口装置连接起来，下图为端子接口实际连接图。</p>\n<p><img src=\"https://ae01.alicdn.com/kf/HTB1NWsMR3HqK1RjSZJnq6zNLpXaZ.jpg\" alt=\"端子接口\"></p>\n<h2 id=\"RS485-串口通信测试\"><a href=\"#RS485-串口通信测试\" class=\"headerlink\" title=\"RS485 串口通信测试\"></a>RS485 串口通信测试</h2><h3 id=\"确认驱动情况\"><a href=\"#确认驱动情况\" class=\"headerlink\" title=\"确认驱动情况\"></a>确认驱动情况</h3><p>将USB转串口装置连接到client，查看是否驱动成功。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dmesg | grep ttyS*</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ae01.alicdn.com/kf/HTB1Nmc9R4naK1RjSZFt762C2VXaO.png\" alt=\"确认串口是否成功驱动\"></p>\n<p>有 <code>ttyUSB0</code>，说明驱动成功。</p>\n<h3 id=\"ModBus-RTU-通讯协议\"><a href=\"#ModBus-RTU-通讯协议\" class=\"headerlink\" title=\"ModBus-RTU 通讯协议\"></a>ModBus-RTU 通讯协议</h3><p>为了能接收到我们想要的信息，我们也必须给 PDU 发送合适的指令，那么我们就需要了解 PDU 究竟想听什么。</p>\n<p>此小节内容主要来自  <a href>CAN-485使用说明书及协议</a> </p>\n<blockquote>\n<p>细心的朋友可能会发现买的 PDU 是某智的，但这个说明书却是某遂的，原因就在于某智其实就是一个套牌的，而真正生产商是某遂。</p>\n</blockquote>\n<h4 id=\"字节结构\"><a href=\"#字节结构\" class=\"headerlink\" title=\"字节结构\"></a>字节结构</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">起始位</th>\n<th style=\"text-align:center\">数据位</th>\n<th style=\"text-align:center\">停止位</th>\n<th style=\"text-align:center\">校验位</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1字节</td>\n<td style=\"text-align:center\">8字节</td>\n<td style=\"text-align:center\">1字节</td>\n<td style=\"text-align:center\">无</td>\n</tr>\n</tbody>\n</table>\n<p>因为程序一般写好了，所以我们一般只要关注<u>数据位</u>就 ok 了。</p>\n<h4 id=\"读取数据请求指令格式\"><a href=\"#读取数据请求指令格式\" class=\"headerlink\" title=\"读取数据请求指令格式\"></a>读取数据请求指令格式</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">设备地址</th>\n<th style=\"text-align:center\">功能编码</th>\n<th style=\"text-align:center\">数据地址H</th>\n<th style=\"text-align:center\">数据地址L</th>\n<th style=\"text-align:center\">字长高位</th>\n<th style=\"text-align:center\">字长地位</th>\n<th style=\"text-align:center\">CRC16 <strong>低</strong>位</th>\n<th style=\"text-align:center\">CRC16 <strong>高</strong>位</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1字节</td>\n<td style=\"text-align:center\">0x03</td>\n<td style=\"text-align:center\">1字节</td>\n<td style=\"text-align:center\">1字节</td>\n<td style=\"text-align:center\">1字节</td>\n<td style=\"text-align:center\">1字节</td>\n<td style=\"text-align:center\">1字节</td>\n<td style=\"text-align:center\">1字节</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>设备地址：在 PDU 上可以设置的地址码，有点类似于 ip 的设定，但只有1位，且取值范围为 <code>1~250</code> </li>\n<li>功能编码：在本 PDU 上只能使用 <code>03</code> 和 <code>06</code>，<code>03</code> 表示读 PDU 寄存器功能，<code>06</code> 表示写入 PDU 寄存器功能 (下文会讲)</li>\n<li>数据地址：在 PDU 寄存器中读取数据的首地址，共2字节，字节高位在前，低位在后。</li>\n<li>数据字长：在 PDU 寄存器中读取数据的长度，共2字节，字节高位在前，低位在后。</li>\n<li>CRC16码：将前面的6个字节进行CRC16校验得到的值，共2字节，字节<strong>低</strong>位在前，<strong>高</strong>位在后。</li>\n</ul>\n<p>举例：<code>01 03 00 00 00 01 84 0A</code> 表示从地址位位1的 PDU 的寄存器上读取数据字长为1的数据，可以通过 <a href=\"http://www.ip33.com/crc.html\" target=\"_blank\" rel=\"noopener\">工具</a> 在线计算出其 CRC16 校验码为 <code>0A84</code> 并根据低位在前，高位在后的原则转换为 <code>84 0A</code>。</p>\n<h4 id=\"响应数据格式\"><a href=\"#响应数据格式\" class=\"headerlink\" title=\"响应数据格式\"></a>响应数据格式</h4><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">地址码</th>\n<th style=\"text-align:center\">功能码</th>\n<th style=\"text-align:center\">数据长度</th>\n<th style=\"text-align:center\">数据区</th>\n<th style=\"text-align:center\">CRC16 校检</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1字节</td>\n<td style=\"text-align:center\">1字节</td>\n<td style=\"text-align:center\">1字节</td>\n<td style=\"text-align:center\">N字节</td>\n<td style=\"text-align:center\">2字节</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>地址码：与请求字段相同。</li>\n<li>功能码：与请求字段相同。</li>\n<li>数据长度：表示数据区字节数。</li>\n<li>数据区：根据功能码不同而不同。</li>\n<li>CRC16码：将前面的N+3个字节进行 CRC16 校验得到的值，共2字节，字节<strong>低</strong>位在前，<strong>高</strong>位在后。</li>\n</ul>\n<p>按照上小节的读取指令返回得到 <code>01 03 02 08 8E 3F E0</code>，前两字节同请求中的前两个字节，<code>02</code> 表示数据区长度为2字节，<code>08 8E</code> 则为数据内容，<code>3F E0</code> 为计算出的 CRC16 校验码。</p>\n<h4 id=\"仪表数据内存地址\"><a href=\"#仪表数据内存地址\" class=\"headerlink\" title=\"仪表数据内存地址\"></a>仪表数据内存地址</h4><p>要想获得功率数据只知道请求指令的格式还不行，还得知道请求的数据究竟存在寄存器的什么地址，才好获取并解析数据。</p>\n<table>\n<thead>\n<tr>\n<th>地址</th>\n<th>参数</th>\n<th>格式</th>\n<th>小数位</th>\n<th>读写属性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0000H</td>\n<td>电压值</td>\n<td>Unsignd int</td>\n<td>1位小数</td>\n<td>R</td>\n</tr>\n<tr>\n<td>0001H</td>\n<td>电流值</td>\n<td>Unsignd int</td>\n<td>2位小数</td>\n<td>R</td>\n</tr>\n<tr>\n<td>0002H</td>\n<td>功率值</td>\n<td>Unsignd int</td>\n<td>无小数位</td>\n<td>R</td>\n</tr>\n<tr>\n<td>0003H</td>\n<td>功率因数</td>\n<td>Unsignd int</td>\n<td>3位小数</td>\n<td>R</td>\n</tr>\n<tr>\n<td>0004H</td>\n<td>有功电能高</td>\n<td>Unsignd long</td>\n<td>无小数位</td>\n<td>RW 写入0xAABB电量清零</td>\n</tr>\n<tr>\n<td>0005H</td>\n<td>有功电能低</td>\n<td>Unsignd long</td>\n<td>无小数位</td>\n<td>RW 写入0xAABB电量清零</td>\n</tr>\n<tr>\n<td>0006H</td>\n<td>通信地址</td>\n<td>Unsignd int</td>\n<td>无小数位</td>\n<td>RW</td>\n</tr>\n<tr>\n<td>0007H</td>\n<td>波特率</td>\n<td>Unsignd int</td>\n<td>无小数位</td>\n<td>RW 0:1200   1:2400 2:4800  3:9600</td>\n</tr>\n<tr>\n<td>0008H</td>\n<td>电流高报警</td>\n<td>Unsignd int</td>\n<td>1位小数</td>\n<td>RW</td>\n</tr>\n<tr>\n<td>0009H</td>\n<td>电压高报警</td>\n<td>Unsignd int</td>\n<td>1位小数</td>\n<td>RW 0-300V</td>\n</tr>\n<tr>\n<td>000AH</td>\n<td>电压低报警</td>\n<td>Unsignd int</td>\n<td>1位小数</td>\n<td>RW 0-300V</td>\n</tr>\n<tr>\n<td>000CH</td>\n<td>电流低报警</td>\n<td>Unsignd int</td>\n<td>1位小数</td>\n<td>RW</td>\n</tr>\n<tr>\n<td>000BH</td>\n<td>显示模式</td>\n<td>Unsignd int</td>\n<td>无小数位</td>\n<td>RW 0：定显    0xff:轮显</td>\n</tr>\n</tbody>\n</table>\n<p>还是刚才那个例子，请求 <code>01 03 00 00 00 01 84 0A</code> 表示从地址0开始请求1个数据字长，也就是电压值。返回得到 <code>01 03 02 08 8E 3F E0</code> 中的 <code>08 8E</code> 转换为10进制为 <code>2190</code>，按照上表给它点上一个小数点就可以得到其电压值为 219V。</p>\n<h3 id=\"CuteCom-测试收发情况\"><a href=\"#CuteCom-测试收发情况\" class=\"headerlink\" title=\"CuteCom 测试收发情况\"></a>CuteCom 测试收发情况</h3><p>了解了请求指令以后，我们就用软件来测试一下是否能请求到数据吧 (*ﾟ∀ﾟ*)</p>\n<ul>\n<li><p>问题：使用 CuteCom 尝试打开串口 <code>/dev/ttyUSB0</code> 时，提示了「无法打开串口 ‘/dev/ttyUSB0’ 」的错误。</p>\n</li>\n<li><p>解决：通过命令 <code>sudo chmod 666 /dev/ttyUSB0</code> 对串口文件赋予读写权限解决问题。</p>\n</li>\n</ul>\n<p>输入符合协议要求指令即可看到成功接收到根据命令返回的16进制数据。</p>\n<p><img src=\"https://ae01.alicdn.com/kf/HTB16m3MRVzqK1RjSZFvq6AB7VXal.jpg\" alt=\"CuteCom\"></p>\n<p>但可以发现，相比 Windows 下用「大傻串口调试工具」</p>\n<ol>\n<li>发送请求和返回请求不带有时间戳信息</li>\n<li>不可以根据用户输入的指令自动计算CRC16校验码</li>\n</ol>\n<h2 id=\"PDU数据采集脚本\"><a href=\"#PDU数据采集脚本\" class=\"headerlink\" title=\"PDU数据采集脚本\"></a>PDU数据采集脚本</h2><p>由于需要做到每秒采集一次并将数据存储下来，因此决定自己写一个 <code>Python</code> 脚本来获取数据。</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><ul>\n<li>通过调用 <code>serial</code> 串口包实现对串口进行读写操作</li>\n<li>通过每秒对串口 <code>write</code> 固定指令再通过 <code>readline()</code> 读取返回的数据</li>\n<li>把返回的数据分段补全并通过 <code>struct.unpack</code> 解析回我们能读懂的数据</li>\n<li>将解析到的数据写入以每日日期命名的 csv 文件中</li>\n</ul>\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><ol>\n<li><p>接收到的数据中包含非十六进制数据字符</p>\n<ul>\n<li>其实只是这些十六进制能被转换成字符而已</li>\n</ul>\n</li>\n<li><p>十六进制的byte字符串转十六进制字符串再转浮点数</p>\n<ul>\n<li>不用转十六进制字符串，直接用 <code>struct.unpack</code> 函数转为 <code>unsigned int/long</code>，再用除法取小数点</li>\n</ul>\n</li>\n<li><p>智能电表内存中存储的有功电能是以<code>unsigned long</code>存储的，并且没有小数位，那显示器上的小数点是怎么来的？</p>\n<ul>\n<li>技术回答的糊里糊涂，说小数部分没存到内存中；但我猜测可能是写通讯协议的人认为电量数据不用传输地那么精细，所以就只把整数部分传了过来。</li>\n</ul>\n</li>\n<li><p>通过 <code>sleep</code> 函数设置的时间间隔，会导致0.1ms(至少0.001ms)左右的延时</p>\n<ul>\n<li>思路不对，当时 <code>sleep</code> 都是根据用 $时间间隔 - 函数执行时间$ ，但在执行其他语句过程中难免会消耗时间，所以会产生 $0.00x$ s的偏差</li>\n<li>可通过 $时间间隔 - 当前时间 \\% 时间间隔$ 来作为 <code>sleep</code> 时间，以保证每次都是在特定时间点执行函数。再加入一个时间差项以 match 上 <code>collectd</code> 的时间</li>\n</ul>\n</li>\n<li><p>运行一段时间后，脚本因为未能读取到特定长度的 <code>bytes</code> 而中断了</p>\n<ul>\n<li>通过添加取得 <code>bytes</code> 时判断其长度是否满足条件的循环，不满足再读一次</li>\n</ul>\n</li>\n<li><p>运行过程中会读取到非常大的异常数据，比如说 <code>1542372466,308.0,599.04,10240,21.763,2533359616</code></p>\n<ul>\n<li>通过存储每次读入的 <code>byte</code>，发现有的只读取了16位而不是正常的17位，然后下面重新读取的第一位并非 <code>b&#39;\\x01&#39;</code>，然后推测时 <code>readline()</code> 等待的 <code>timeout</code> 时间设置的太短了(为0.05s)，有的时候数据还没传完，就结束当前次读取了，导致下一次读取错位，然后解析就出错了。修改 timeout 时间为0.1s，并且判断返回的前两位是否为 <code>b&#39;\\x01\\x03&#39;</code>，否则重读</li>\n</ul>\n</li>\n<li><p>虽然采集到的数据长度看起来没什么异常了，但是查看输出log的时候发现，在有一次获取数据的过程中，在某一秒内重新获取了数据非常多次，但只有在下$x$秒的时候才获取到了正常数据，这和我们要获得精准数据的计划不同。</p>\n<blockquote>\n<p>1542437616<br><br>b’\\x01\\x03\\x0c\\t\\n’<br><br>1542437616<br><br>b’\\x00)\\x00U\\x03\\x80\\x00\\x00\\x00\\x04X\\x0e\\x01\\x03\\x0c\\t\\n’<br><br>…重复26次…<br><br>1542437617<br><br>b’\\x00)\\x00U\\x03|\\x00\\x00\\x00\\x04\\x08\\x1a\\x01\\x03\\x0c\\t\\n’<br><br>…重复27次…<br><br>1542437618<br><br>b’\\x00)\\x00W\\x03\\x8f\\x00\\x00\\x00\\x04/\\xcf\\x01\\x03\\x0c\\t\\n’<br><br>…重复4次…<br><br>1542437618<br><br>b’\\x00)\\x00U\\x03\\x84\\x00\\x00\\x00\\x04\\xa9\\xce\\x01\\x03\\x0c\\t\\n’<br><br>…重复21次…<br><br>1542437619<br><br>b’\\x00)\\x00U\\x03\\x84\\x00\\x00\\x00\\x04\\xa9\\xce\\x01\\x03\\x0c\\t\\n’<br><br>…重复27次…<br><br>1542437620<br><br>b’\\x00)\\x00V\\x03\\x87\\x00\\x00\\x00\\x04\\xde\\xce\\x01\\x03\\x0c\\t\\n’<br><br>…重复5次…<br><br>1542437620<br><br>b’\\x00(\\x00V\\x03\\x8d\\x00\\x00\\x00\\x04K_\\x01\\x03\\x0c\\t\\n’<br><br>…重复21次…<br><br>1542437621<br><br>b’\\x00(\\x00V\\x03\\x8d\\x00\\x00\\x00\\x04K_\\x01\\x03\\x0c\\t\\n’<br><br>…重复3次…<br><br>1542437621<br><br>b’\\x00(\\x00V\\x03\\x8d\\x00\\x00\\x00\\x04K_\\x01\\x03\\x0c\\t\\x0b\\x00(\\x00V\\x03\\x8c\\x00\\x00\\x00\\x04rc’<br><br>1542437621<br><br>b’\\x01\\x03\\x0c\\t\\x0b\\x00(\\x00V\\x03\\x8c\\x00\\x00\\x00\\x04rc’</p>\n</blockquote>\n<ul>\n<li>这是由于第一次没有取得17位 <code>bytes</code> 导致之后读取一直都无法准确读取到正确的 <code>bytes</code>，所以在读取出错的时候再进行一次 <code>readline()</code>，将之前没读完的 <code>byte</code> 读完，再重新获取数据。</li>\n</ul>\n</li>\n<li><p>虽然解决了数据错位问题的重读问题，但可以从输出的log中发现还是会有短数据重读的，而经常出现的还是 <code>b&#39;\\x01\\x03\\x0c\\t\\n&#39;</code> 这段 <code>bytes</code>，于是搜索了一下 <code>\\n</code> 结果发现不光这段短数据重读了，有的出现在倒数几位的 <code>\\n</code> 也重读了，由此可以推断 <code>\\n</code> 才是数据重读的罪魁祸首，这应该是受限于 <code>readline()</code> 函数的定义，遇到换行符则停止。</p>\n<ul>\n<li>所以在每次读取完成后，判断一下最后一位是否为 <code>b&#39;\\n&#39;</code>，如果是的话，就再进行一次 <code>readline()</code>。</li>\n<li>为了防止一次数据中有两个 <code>b&#39;\\n&#39;</code>，当读取一次后，数据长度非17位时，循环 <code>readline()</code>，而当其读取到的是 <code>b&#39;&#39;</code> 时，跳出循环。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><ul>\n<li><p>功能函数文件: <a href=\"https://github.com/10382/can-pdu-datareader/blob/master/monitorfun.py\" target=\"_blank\" rel=\"noopener\"><code>monitorfun.py</code></a></p>\n</li>\n<li><p>主文件: <a href=\"https://github.com/10382/can-pdu-datareader/blob/master/main.py\" target=\"_blank\" rel=\"noopener\"><code>main.py</code></a></p>\n</li>\n</ul>\n<h2 id=\"CAN-485-说明书未列出的操作\"><a href=\"#CAN-485-说明书未列出的操作\" class=\"headerlink\" title=\"CAN-485 说明书未列出的操作\"></a>CAN-485 说明书未列出的操作</h2><h3 id=\"修改从机-PDU-存储的数据\"><a href=\"#修改从机-PDU-存储的数据\" class=\"headerlink\" title=\"修改从机 (PDU) 存储的数据\"></a>修改从机 (PDU) 存储的数据</h3><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">地址码</th>\n<th style=\"text-align:center\">功能码</th>\n<th style=\"text-align:center\">数据地址</th>\n<th style=\"text-align:center\">写入数据</th>\n<th style=\"text-align:center\">CRC16校验码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1字节</td>\n<td style=\"text-align:center\">0x06</td>\n<td style=\"text-align:center\">2字节</td>\n<td style=\"text-align:center\">2字节</td>\n<td style=\"text-align:center\">2字节</td>\n</tr>\n</tbody>\n</table>\n<p>如果需要将用电度数清零，则需要发送的指令如下:</p>\n<p><code>01 06 00 04 AA BB F6 D8</code> 和 <code>01 06 00 05 AA BB A7 18</code></p>\n<p>参考文章: </p>\n<ul>\n<li><a href=\"https://blog.csdn.net/brucezcg/article/details/70340361\" target=\"_blank\" rel=\"noopener\">ModBus-RTU详解</a></li>\n<li><a href=\"http://www.elecfans.com/d/631762.html\" target=\"_blank\" rel=\"noopener\">modbus rtu六种功能码详细解析</a></li>\n</ul>\n","thumbnail":"https://ae01.alicdn.com/kf/HTB1w3s8RW6qK1RjSZFmq6x0PFXaC.jpg","categories":[{"name":"能效预测","path":"api/categories/能效预测.json"}],"tags":[{"name":"PDU","path":"api/tags/PDU.json"},{"name":"RS485","path":"api/tags/RS485.json"},{"name":"Python","path":"api/tags/Python.json"}]}